import{_ as r,C as d,c as n,o as s,ak as l,j as e,a as t,G as p}from"./chunks/framework.CK5UQgAU.js";const i="/plop-page.gif",m="/plop-component.gif",u="/plop-store.gif",c="/plop-mock.gif",g="/plop-module.gif",v=JSON.parse('{"title":"代码文件自动生成","description":"","frontmatter":{},"headers":[],"relativePath":"guide/plop.md","filePath":"guide/plop.md"}'),f={name:"guide/plop.md"},k={id:"module",tabindex:"-1"};function _(b,o,h,x,T,P){const a=d("Badge");return s(),n("div",null,[o[9]||(o[9]=l('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /guide/plop.md for this page in Markdown format</div><h1 id="代码文件自动生成" tabindex="-1">代码文件自动生成 <a class="header-anchor" href="#代码文件自动生成" aria-label="Permalink to &quot;代码文件自动生成&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>该功能基于 <a href="https://www.npmjs.com/package/plop" target="_blank" rel="noreferrer">plop</a> 实现，在扩展新的模式前，请先详细阅读 plop 官方文档。</p></div><p>开发过程中，避免不了手动去频繁创建页面、组件等文件，并且还要在文件里写一些必要的代码，是不是觉得很麻烦？现在你可以用更简洁的方式来处理这一切。</p><p>框架默认提供了 5 种模式，通过 <code>pnpm run new</code> 指令可以自行选择。</p>',5)),e("ul",null,[o[2]||(o[2]=e("li",null,[e("code",null,"page"),t(" 页面文件")],-1)),o[3]||(o[3]=e("li",null,[e("code",null,"component"),t(" 组件文件")],-1)),o[4]||(o[4]=e("li",null,[e("code",null,"store"),t(" pinia 全局状态文件")],-1)),o[5]||(o[5]=e("li",null,[e("code",null,"mock"),t(" mock 文件")],-1)),e("li",null,[o[0]||(o[0]=e("code",null,"module",-1)),o[1]||(o[1]=t(" 页面模块文件 ",-1)),p(a,{type:"pro",text:"专业版"})])]),o[10]||(o[10]=l('<p>除了框架提供的 5 种模式，你还可以自定义新的模式，其原理就是通过预设模板，按照特定规则创建文件或者文件夹。</p><p>预设模板文件存放在 <code>/plop-templates/</code> 目录下，并在 <code>/plopfile.js</code> 文件里进行引用，你可以参考现有 5 种模式的目录结构进行创建新的模板。</p><h2 id="page" tabindex="-1">page <a class="header-anchor" href="#page" aria-label="Permalink to &quot;page&quot;">​</a></h2><p><img src="'+i+'" alt="" data-zoomable=""></p><p>page 模式下，只能在 <code>/src/views/</code> 目录下选择指定的文件夹进行生成，生成的文件中，部分关键位置会被替换掉，例如 <code>&lt;page-header /&gt;</code> 中的 <code>title</code> 会按照你输入的中文名称替换，页面的 <code>name</code> 会根据当前文件目录和文件名自动生成，确保唯一。</p><h2 id="component" tabindex="-1">component <a class="header-anchor" href="#component" aria-label="Permalink to &quot;component&quot;">​</a></h2><p><img src="'+m+'" alt="" data-zoomable=""></p><p>component 模式可以选择生成的是公共组件还是局部组件，公共组件生成目录为 <code>/src/components/</code> ，局部组件则在 <code>/src/views/</code> 目录下选择指定的文件夹进行生成。</p><h2 id="store" tabindex="-1">store <a class="header-anchor" href="#store" aria-label="Permalink to &quot;store&quot;">​</a></h2><p><img src="'+u+'" alt="" data-zoomable=""></p><p>store 模式则会在 <code>/src/store/modules/</code> 目录下生成一个空模板</p><h2 id="mock" tabindex="-1">mock <a class="header-anchor" href="#mock" aria-label="Permalink to &quot;mock&quot;">​</a></h2><p><img src="'+c+'" alt="" data-zoomable=""></p><p>mock 模式则会在 <code>/src/mock/</code> 目录下生成一个标准 CURD 的 mock 数据</p>',14)),e("h2",k,[o[6]||(o[6]=t("module ",-1)),p(a,{type:"pro",text:"专业版"}),o[7]||(o[7]=t()),o[8]||(o[8]=e("a",{class:"header-anchor",href:"#module","aria-label":'Permalink to "module <Badge type="pro" text="专业版" />"'},"​",-1))]),o[11]||(o[11]=e("p",null,[e("img",{src:g,alt:"","data-zoomable":""})],-1)),o[12]||(o[12]=e("p",null,"module 模式是一个标准模块模板，会在指定目录下生成模块文件夹，并且包含列表页、编辑（详情）页，以及相关局部组件。",-1)),o[13]||(o[13]=e("p",null,[t("这块部分详细介绍请阅读《"),e("a",{href:"./plop-module.html"},"标准模块"),t("》。")],-1))])}const N=r(f,[["render",_]]);export{v as __pageData,N as default};
